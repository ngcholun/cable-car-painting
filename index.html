<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cable Car Ride (Rope Editor + Clean Mask)</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
    }
    h1 {
      font-size: 1.2rem;
      margin: 10px;
      text-align: center;
      color: white;
      background: rgba(0,0,0,0.6);
      padding: 6px 12px;
      border-radius: 6px;
    }
    #controls {
      color: white;
      margin: 8px;
      font-size: 0.9rem;
      text-align: center;
    }
    #upload {
      margin: 10px;
    }
    #scene {
      position: relative;
      flex: 1;
      width: 100%;
      max-width: 1052px;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    #background {
      width: 100%;
      height: auto;
      display: block;
      position: relative;
      z-index: 0;
    }
    #ropeOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    .handle {
      position: absolute;
      width: 18px;
      height: 18px;
      background: yellow;
      border: 2px solid red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: 3;
      cursor: grab;
      touch-action: none;
    }
    .car-container {
      position: absolute;
      transform-origin: center center;
      z-index: 2;
    }
    .car-container img {
      width: 120px;
      transform-origin: top center;
    }
    #coords {
      color: white;
      font-size: 0.8rem;
      margin: 5px;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¨ Upload Cabin (Drag Rope Ends to Adjust)</h1>

  <div id="controls">
    <label for="speedSlider">Speed:</label>
    <input type="range" id="speedSlider" min="0.0002" max="0.003" step="0.0001" value="0.0007">
    <span id="speedValue">0.0007</span>
    <br>
    <label for="threshSlider">BG Threshold:</label>
    <input type="range" id="threshSlider" min="150" max="255" step="1" value="200">
    <span id="threshValue">200</span>
    <br>
    <button id="clearBtn">Clear Cars</button>
    <button id="toggleRopeBtn">Hide Rope</button>
  </div>

  <input type="file" id="upload" accept="image/*">

  <div id="scene">
    <img id="background" src="mountain.jpg" alt="Cable Car Background">
    <canvas id="ropeOverlay"></canvas>
    <div id="handleStart" class="handle"></div>
    <div id="handleEnd" class="handle"></div>
  </div>

  <div id="coords">Coords: Start(129,450) End(940,1)</div>

  <canvas id="canvas" style="display:none;"></canvas>

  <script>
    const upload = document.getElementById('upload');
    const scene = document.getElementById('scene');
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    const threshSlider = document.getElementById('threshSlider');
    const threshValue = document.getElementById('threshValue');
    const clearBtn = document.getElementById('clearBtn');
    const bg = document.getElementById("background");
    const ropeOverlay = document.getElementById("ropeOverlay");
    const ropeCtx = ropeOverlay.getContext("2d");
    const toggleRopeBtn = document.getElementById("toggleRopeBtn");
    const coordsEl = document.getElementById("coords");

    const handleStart = document.getElementById("handleStart");
    const handleEnd = document.getElementById("handleEnd");

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let natW = 1, natH = 1;

    // ropes
    let ropeStart = { x: 129, y: 450 };
    let ropeEnd   = { x: 940, y: 1 };

    const TOP_CROP = 0.1;
    const BOTTOM_CROP = 0.2;
    let MORPH_THRESHOLD = parseInt(threshSlider.value);

    let cars = [];
    const MAX_CARS = 5;
    let SPEED = parseFloat(speedSlider.value);
    let globalProgress = 0;

    // ---- Controls ----
    bg.onload = () => { natW = bg.naturalWidth; natH = bg.naturalHeight; resizeOverlay(); };
    window.addEventListener("resize", resizeOverlay);

    function resizeOverlay() {
      ropeOverlay.width = bg.clientWidth;
      ropeOverlay.height = bg.clientHeight;
    }

    speedSlider.addEventListener('input', () => {
      SPEED = parseFloat(speedSlider.value);
      speedValue.textContent = SPEED.toFixed(4);
    });

    threshSlider.addEventListener('input', () => {
      MORPH_THRESHOLD = parseInt(threshSlider.value);
      threshValue.textContent = MORPH_THRESHOLD;
    });

    clearBtn.addEventListener("click", () => {
      cars.forEach(c => c.el.remove());
      cars = [];
    });

    // Rope toggle
    let ropeVisible = true;
    toggleRopeBtn.addEventListener("click", () => {
      ropeVisible = !ropeVisible;
      toggleRopeBtn.textContent = ropeVisible ? "Hide Rope" : "Show Rope";
      handleStart.style.display = ropeVisible ? "block" : "none";
      handleEnd.style.display   = ropeVisible ? "block" : "none";
      coordsEl.style.display    = ropeVisible ? "block" : "none";
    });

    // ---- Rope Drawing ----
    function drawRopeLine(startX, startY, endX, endY) {
      ropeCtx.clearRect(0, 0, ropeOverlay.width, ropeOverlay.height);
      if (!ropeVisible) return;
      ropeCtx.strokeStyle = "red";
      ropeCtx.lineWidth = 2;
      ropeCtx.beginPath();
      ropeCtx.moveTo(startX, startY);
      ropeCtx.lineTo(endX, endY);
      ropeCtx.stroke();
    }

    function animateCars() {
      const time = Date.now();
      const bgW = bg.clientWidth, bgH = bg.clientHeight;

      const scale = bgW / natW;
      const displayH = natH * scale;
      const offsetY = (bgH - displayH) / 2;

      const startX = ropeStart.x * scale, startY = ropeStart.y * scale + offsetY;
      const endX   = ropeEnd.x * scale,   endY   = ropeEnd.y * scale + offsetY;

      drawRopeLine(startX, startY, endX, endY);

      handleStart.style.left = startX + "px";
      handleStart.style.top  = startY + "px";
      handleEnd.style.left   = endX + "px";
      handleEnd.style.top    = endY + "px";

      coordsEl.textContent = `Coords: Start(${Math.round(ropeStart.x)},${Math.round(ropeStart.y)}) End(${Math.round(ropeEnd.x)},${Math.round(ropeEnd.y)})`;

      cars.forEach(car => {
        let progress = (globalProgress + car.offset) % 1;
        const x = startX + (endX - startX) * progress;
        const y = startY + (endY - startY) * progress;
        const scaleCar = 0.3 + (3 - 0.3) * progress;
        const swing = Math.sin(time / 500 + car.swingOffset) * 5;
        car.el.style.left = x + "px";
        car.el.style.top  = y + "px";
        car.el.style.transform = `scale(${scaleCar}) rotate(${swing}deg)`;
      });

      globalProgress = (globalProgress + SPEED) % 1;
      requestAnimationFrame(animateCars);
    }

    function rebuildOffsets() {
      cars.forEach((car, idx) => { car.offset = idx / cars.length; });
    }

    function addCar(dataUrl) {
      if (cars.length >= MAX_CARS) { cars[0].el.remove(); cars.shift(); }
      const container = document.createElement('div');
      container.className = "car-container";
      const imgEl = document.createElement('img');
      imgEl.src = dataUrl;
      container.appendChild(imgEl);
      scene.appendChild(container);
      cars.push({ el: container, offset: 0, swingOffset: Math.random() * Math.PI * 2 });
      rebuildOffsets();
    }

    // ---- Background removal with morphology ----
    function removeBackground(img, threshold = MORPH_THRESHOLD) {
      const cropX = 0, cropY = img.height * TOP_CROP;
      const cropW = img.width, cropH = img.height * (1 - TOP_CROP - BOTTOM_CROP);

      canvas.width = cropW; canvas.height = cropH;
      ctx.clearRect(0, 0, cropW, cropH);
      ctx.drawImage(img, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

      let imageData = ctx.getImageData(0, 0, cropW, cropH);
      let data = imageData.data;

      // Step 1. Threshold by brightness
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2];
        const brightness = 0.299*r + 0.587*g + 0.114*b;
        if (brightness > threshold) data[i+3] = 0;
      }
      ctx.putImageData(imageData, 0, 0);

      // Step 2. Blur alpha
      let blurred = ctx.getImageData(0, 0, cropW, cropH);
      let bd = blurred.data;
      const rad = 2;
      for (let y = rad; y < cropH-rad; y++) {
        for (let x = rad; x < cropW-rad; x++) {
          let sum = 0, count = 0;
          for (let dy = -rad; dy <= rad; dy++) {
            for (let dx = -rad; dx <= rad; dx++) {
              const idx = ((y+dy)*cropW + (x+dx))*4 + 3;
              sum += data[idx];
              count++;
            }
          }
          const idx = (y*cropW + x)*4 + 3;
          bd[idx] = sum / count;
        }
      }

      // Step 3. Re-threshold
      for (let i = 3; i < bd.length; i += 4) {
        bd[i] = bd[i] > 128 ? 255 : 0;
      }
      ctx.putImageData(blurred, 0, 0);

      return canvas.toDataURL("image/png");
    }

    upload.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          const cleaned = removeBackground(img, MORPH_THRESHOLD);
          addCar(cleaned);
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
      event.target.value = "";
    });

    // ---- Dragging rope handles ----
    function makeDraggable(handle, target) {
      let dragging = false;
      function onDown(e) { e.preventDefault(); dragging = true; handle.style.cursor = "grabbing"; }
      function onMove(e) {
        if (!dragging) return;
        const rect = scene.getBoundingClientRect();
        const bgW = bg.clientWidth, scale = bgW / natW;
        const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        const bgH = bg.clientHeight;
        const displayH = natH * scale, offsetY = (bgH - displayH) / 2;
        target.x = x / scale;
        target.y = (y - offsetY) / scale;
      }
      function onUp() { dragging = false; handle.style.cursor = "grab"; }
      handle.addEventListener("mousedown", onDown);
      handle.addEventListener("touchstart", onDown);
      window.addEventListener("mousemove", onMove);
      window.addEventListener("touchmove", onMove);
      window.addEventListener("mouseup", onUp);
      window.addEventListener("touchend", onUp);
    }

    makeDraggable(handleStart, ropeStart);
    makeDraggable(handleEnd, ropeEnd);

    requestAnimationFrame(animateCars);
  </script>
</body>
</html>